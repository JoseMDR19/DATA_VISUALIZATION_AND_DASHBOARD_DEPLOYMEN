# -*- coding: utf-8 -*-
"""App

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PdD4wYdMddsHwgfc1Q6lsluvoVG1AsfI

# Activity 1 — Data Visualization and Dashboard Deployment

**Universidad de la costa – Data Mining**  
**Instructor:** José Escorcia-Gutiérrez, Ph.D.  
**Integrantes del grupo:** Jose Diaz (Grupo 10895) , Melanny Doncel (Grupo 10919)

# Notebook preparado para:
1. Cargar y explorar `university_student_data.csv`.
2. Generar visualizaciones solicitadas.
3. Preparar datos y artefactos para desplegar un dashboard en Streamlit.

# Instrucciones:
- Sube el archivo `university_student_data.csv` usando el botón de archivos o ejecuta la celda de upload.
- Si el archivo ya está en un path local, la lectura intentará usarlo.

#1) Instalación de librerías (ejecutar sólo si falta alguna)
"""

!pip install -q seaborn plotly streamlit pyngrok altair pandas

"""#2) Importar librerías"""

import os
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
from IPython.display import display, Markdown

# Estilo de gráficos
sns.set(style="whitegrid")
plt.rcParams['figure.figsize'] = (10,5)

"""#3) Cargar el dataset"""

default_path = "/mnt/data/university_student_data.csv"

if os.path.exists(default_path):
    df = pd.read_csv(default_path)
    print(f"Leído desde {default_path}")
else:
    # widget de subida
    from google.colab import files
    uploaded = files.upload()
    # tomamos el primer archivo subido
    fn = list(uploaded.keys())[0]
    df = pd.read_csv(fn)
    print(f"Leído desde archivo subido: {fn}")

print("Tamaño del dataframe:", df.shape)

"""#4) Vista rápida del dataset
- Muestra primeras filas, info, estadísticos.
"""

display(df.head(10))
display(df.info())
display(df.describe(include='all').T)

"""#5) Generar automáticamente una tabla de columnas y ejemplos
Esto ayuda a documentar las columnas disponibles y sus tipos.
"""

col_table = pd.DataFrame({
    "column": df.columns,
    "dtype": [str(df[c].dtype) for c in df.columns],
    "n_unique": [df[c].nunique(dropna=False) for c in df.columns],
    "example_values": [df[c].dropna().unique()[:5].tolist() if df[c].dropna().size>0 else [] for c in df.columns]
})
display(col_table)
Markdown("**Sugerencia:** edita la tabla anterior localmente y describe cada columna en términos del contexto (ej. 'year' = año académico, 'department' = nombre de la facultad, 'term' = 'Spring'/'Fall', 'retention_rate' = tasa de retención en %).")

"""#6) Convertir tipos y limpiar datos
- Convertimos columnas fecha/año a tipo correcto.
- Aseguramos que `term` y `department` sean categóricas.
"""

possible_year_cols = [c for c in df.columns if 'year' in c.lower() or 'anio' in c.lower() or 'año' in c.lower()]
if possible_year_cols:
    year_col = possible_year_cols[0]
    try:
        df[year_col] = df[year_col].astype(int)
        print("Usando columna de año:", year_col)
    except:
        pass
else:
    year_col = None

# Detectar term
possible_term_cols = [c for c in df.columns if 'term' in c.lower() or 'semester' in c.lower() or 'period' in c.lower()]
term_col = possible_term_cols[0] if possible_term_cols else None

# Detectar department
possible_dept_cols = [c for c in df.columns if 'dept' in c.lower() or 'department' in c.lower() or 'facult' in c.lower()]
dept_col = possible_dept_cols[0] if possible_dept_cols else None

print("Detected:", {"year_col": year_col, "term_col": term_col, "dept_col": dept_col})
if term_col:
    df[term_col] = df[term_col].astype(str)
if dept_col:
    df[dept_col] = df[dept_col].astype(str)

"""#7) Funciones auxiliares para agregaciones comunes
- Ajusta `retention_col` y `satisfaction_col` si tus columnas se llaman distinto.
"""

# Detectar nombres comunes
cols_lower = [c.lower() for c in df.columns]
retention_candidates = [c for c in df.columns if 'retain' in c.lower() or 'retention' in c.lower()]
satisfaction_candidates = [c for c in df.columns if 'satisf' in c.lower() or 'satisfaction' in c.lower() or 'satis' in c.lower()]

retention_col = retention_candidates[0] if retention_candidates else None
satisfaction_col = satisfaction_candidates[0] if satisfaction_candidates else None

print("Candidates -> retention:", retention_col, "satisfaction:", satisfaction_col)

"""#8) Visualización 1 — Tendencia de la tasa de retención a lo largo del tiempo
- Si no existe una columna `retention_rate`, calculamos una aproximación con `retained` / `enrolled` si están disponibles.
"""

# Intentar crear 'retention_rate' si no existe
if retention_col is None:
    # buscar columnas 'retained' y 'enrolled'
    retained_col = next((c for c in df.columns if 'retain' in c.lower() and 'rate' not in c.lower()), None)
    enrolled_col = next((c for c in df.columns if 'enroll' in c.lower() or 'enrolled' in c.lower()), None)
    if retained_col and enrolled_col:
        df['retention_rate'] = (df[retained_col] / df[enrolled_col]) * 100
        retention_col = 'retention_rate'
        print("Se creó 'retention_rate' usando", retained_col, "/", enrolled_col)
    else:
        print("No se encontró forma de crear 'retention_rate' automáticamente. Define manualmente la columna de retención.")
else:
    # si existe, aseguramos que sea numérica
    df[retention_col] = pd.to_numeric(df[retention_col], errors='coerce')

# Agrupar por año y graficar
if year_col and retention_col:
    df_year = df.groupby(year_col)[retention_col].mean().reset_index()
    plt.figure(figsize=(10,5))
    sns.lineplot(data=df_year, x=year_col, y=retention_col, marker='o')
    plt.title("Tendencia de la tasa de retención por año")
    plt.ylabel("Retention rate (%)")
    plt.xlabel(year_col)
    plt.grid(True)
    plt.show()
else:
    print("Necesitamos una columna de año y una de retención para esta gráfica. Verifica nombres detectados.")

"""#9) Visualización 2 — Satisfacción estudiantil por año
- Si existe `satisfaction_score` se usa directamente; si no, intenta detectar columnas relevantes.
"""

if satisfaction_col:
    df[satisfaction_col] = pd.to_numeric(df[satisfaction_col], errors='coerce')
    if year_col:
        df_sat = df.groupby(year_col)[satisfaction_col].mean().reset_index()
        plt.figure(figsize=(10,5))
        sns.lineplot(data=df_sat, x=year_col, y=satisfaction_col, marker='o')
        plt.title("Puntaje medio de satisfacción por año")
        plt.ylabel("Satisfaction score")
        plt.xlabel(year_col)
        plt.show()
    else:
        # si no hay año, mostramos distribución
        plt.figure(figsize=(8,5))
        sns.histplot(df[satisfaction_col].dropna(), bins=20, kde=True)
        plt.title("Distribución de puntajes de satisfacción")
        plt.show()
else:
    print("No se detectó columna de satisfacción automáticamente. asigna `satisfaction_col` y vuelve a ejecutar.")

"""#10) Visualización 3 — Comparación entre Spring y Fall terms
- Filtramos por `term` y mostramos comparaciones (retención y satisfacción).
"""

if term_col:
    # normalizar valores (ej. 'Spring', 'Fall')
    df[term_col] = df[term_col].str.capitalize().str.strip()
    terms = df[term_col].unique()
    print("Términos detectados:", terms)

    # Retención por término
    if retention_col:
        term_ret = df.groupby(term_col)[retention_col].mean().reset_index().sort_values(retention_col, ascending=False)
        display(term_ret)
        plt.figure(figsize=(8,5))
        sns.barplot(data=term_ret, x=term_col, y=retention_col)
        plt.title("Tasa de retención promedio por término")
        plt.ylabel("Retention rate (%)")
        plt.show()
    # Satisfacción por término
    if satisfaction_col:
        term_sat = df.groupby(term_col)[satisfaction_col].mean().reset_index().sort_values(satisfaction_col, ascending=False)
        display(term_sat)
        plt.figure(figsize=(8,5))
        sns.barplot(data=term_sat, x=term_col, y=satisfaction_col)
        plt.title("Satisfacción promedio por término")
        plt.ylabel("Satisfaction score")
        plt.show()
else:
    print("No se encontró columna de término/semester. Si existe con otro nombre, indícalo en `term_col`.")

"""#11) Visualizaciones interactivas (Plotly) — opcional pero útiles para Streamlit"""

# Línea interactiva de retención por año (Plotly)
if year_col and retention_col:
    fig = px.line(df.groupby(year_col)[retention_col].mean().reset_index(), x=year_col, y=retention_col,
                  title="Tendencia interactiva de retención por año", markers=True)
    fig.show()

# Boxplot interactivo de satisfacción por departamento (si existe department)
if dept_col and satisfaction_col:
    fig2 = px.box(df, x=dept_col, y=satisfaction_col, title="Satisfacción por departamento (boxplot)")
    fig2.show()

"""#12) Preparar dataset para Streamlit (guardar csv procesado)"""

processed_path = "processed_university_student_data.csv"
df.to_csv(processed_path, index=False)
print("Archivo procesado guardado en:", processed_path)